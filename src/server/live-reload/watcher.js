// Copyright (c) Microsoft Corporation. All rights reserved.

var config = require('../config');
var fs = require('fs');
var log = require('../log');
var path = require('path');

var EVENT_IGNORE_DURATION = 150;
var WWW_ROOT = 'www';
var MERGES_ROOT = 'merges';
var UNKNOWN_FILE_ID = '__sim-unknown__';

function Watcher(fileChangedCb) {
    this.fileChangedCallback = fileChangedCb;
    this.ignoreEvents = {};
    this.mergesOverridePath = path.join(config.projectRoot, MERGES_ROOT, config.platform);
    this.mergesOverrideExists = fs.existsSync(this.mergesOverridePath);
}

Watcher.prototype.startWatching = function () {
    this.wwwWatcher = fs.watch(path.join(config.projectRoot, WWW_ROOT), { recursive: true }, handleWwwWatcherEvent.bind(this));

    if (this.mergesOverrideExists) {
        this.mergesWatcher = fs.watch(path.join(config.projectRoot, MERGES_ROOT, config.platform), { recursive: true }, handleMergesWatcherEvent.bind(this));
    }
};

Watcher.prototype.stopWatching = function () {
    if (this.wwwWatcher) {
        this.wwwWatcher.close();
        this.wwwWatcher = null;
    }

    if (this.mergesWatcher) {
        this.mergesWatcher.close();
        this.mergesWatcher = null;
    }
};

function handleWwwWatcherEvent(event, fileRelativePath) {
    handleWatcherEvent.bind(this)(WWW_ROOT, fileRelativePath);
}

function handleMergesWatcherEvent(event, fileRelativePath) {
    handleWatcherEvent.bind(this)(MERGES_ROOT, fileRelativePath);
}

function handleWatcherEvent(root, fileRelativePath) {
    // fs.watch() will often send events more than once for the same modification, especially on Windows. A workaround is to block events generated by the same file for a short duration.
    var ignoreId = fileRelativePath || UNKNOWN_FILE_ID;

    if (this.ignoreEvents[ignoreId]) {
        return;
    }

    this.ignoreEvents[ignoreId] = true;
    setTimeout(function () {
        this.ignoreEvents[ignoreId] = false;
    }.bind(this), EVENT_IGNORE_DURATION);

    if (!fileRelativePath) {
        // fs.watch() doesn't always set the fileRelativePath argument properly. If that happens, let the user know.
        log.warning('Could not reload the modified file because fs.watch() didn\'t specify which file was changed');

        return;
    }

    // Make sure the event is for a file, not a directory
    var isWww = root === WWW_ROOT;
    var srcPathPrefix = isWww ? path.join(config.projectRoot, WWW_ROOT) : this.mergesOverridePath;
    var fileAbsolutePath = path.join(srcPathPrefix, fileRelativePath);

    if (fs.statSync(fileAbsolutePath).isDirectory()) {
        return;
    }

    // If the modified file is under www/, but has a merges/[platform]/ override, we don't do anything (because the running app is not using the file that was just modified).
    if (isWww && fileHasMergesOverride.bind(this)(fileRelativePath)) {
        return;
    }

    // Invoke the file changed callback.
    if (this.fileChangedCallback && typeof this.fileChangedCallback === 'function') {
        this.fileChangedCallback(fileRelativePath, fileAbsolutePath);
    }
}

function fileHasMergesOverride(fileRelativePath) {
    return this.mergesOverrideExists && fs.existsSync(path.join(this.mergesOverridePath, fileRelativePath));
}

exports.Watcher = Watcher;
